'Code options
Option Strict On 'variable types must match
Option Explicit On 'variables types must be defined

'Importing TCP stuff to make it easier to code
Imports System.Net
Imports System.Net.Sockets
Imports System.Threading

Public Class SingleAxisIO
    'Property for simulating the gantry:
    Private SimulatedGantry As Boolean = False
    Public Property Simulated As Boolean
        Get
            Return SimulatedGantry
        End Get
        Set(value As Boolean)
            SimulatedGantry = value
        End Set
    End Property

    'Property for setting up the device IP:
    Private _DeviceIP As String = ""
    Public Property DeviceIP As String
        Get
            Return _DeviceIP
        End Get
        Set(value As String)
            If IsIPaddressValid(value) Then
                _DeviceIP = value
            Else
                _DeviceIP = ""
            End If
        End Set
    End Property

    Private Function IsIPaddressValid(ByVal _address As String) As Boolean
        Dim address As New IPAddress(0)
        Return IPAddress.TryParse(_address, address)
    End Function

    'Property for setting the device port:
    Public DevicePort As Integer = 0

    'TCP objects:
    Private WithEvents TCPClient As TcpClient
    Private TCPstream As NetworkStream
    Private TCPlock As New Object
    'Device status storage and timer(s)
    Public DeviceStatus As New CVE_Data
    Private WithEvents DeviceStatusUpdateTimer As New Threading.Timer(AddressOf DeviceStatusUpdateTimer_Tick)
    'Property Gantry Position relative to home switch
    Public Property PositionFromHome As Double
        Get
            Return CDbl(ReadCVEObject(56)) / 1000
        End Get
        Set(value As Double)
            'fist, determine where we are now
            Dim StartLocation As Double = PositionFromHome
            'next, how far do we need to move
            Dim DistanceToMove As Double = StartLocation - value
            'set the record to that value
            SetPositionRecordRelativeValue(DistanceToMove)
            'start the move
            MoveToPosition(25)
            'done.
        End Set
    End Property
    'Property Gantry Position relative to mold mouting pin
    Public Property PositionFromMountingPin As Double
        Get
            Return (CDbl(ReadCVEObject(56)) - CDbl(DeviceStatus.TargetPosition)) / 1000
        End Get
        Set(value As Double)
            'fist, determine where we are now (from home)
            Dim StartLocation As Double = PositionFromHome
            'next, how far do we need to move (relavie to home)
            Dim DistanceToMove As Double = (value + (CDbl(CInt(ReadCVEObject(6, 3))) / 1000)) - StartLocation
            'set the record to that value
            SetPositionRecordRelativeValue(DistanceToMove)
            'start the move
            MoveToPosition(25)
            'done.
        End Set
    End Property

    'Connect/disconnect property (read = is active? write = connect/disconnect)
    Public Property Connect As Boolean
        Get
            If IsNothing(TCPClient) Then
                Return False
            Else
                Return TCPClient.Connected
            End If
        End Get
        Set(value As Boolean)
            If value Then
                'yes, they want to connect
                If IsIPaddressValid(_DeviceIP) Then
                    _Connect_to_Device()
                End If
            Else
                _Disconnect_from_Device()
            End If
        End Set
    End Property
    Private Sub _Connect_to_Device()
        If Simulated Then
            Exit Sub
        End If
        Monitor.Enter(TCPlock)
        Try
            TCPClient = New TcpClient(DeviceIP, DevicePort)
            TCPstream = TCPClient.GetStream()
            DeviceStatusUpdateTimer.Change(250, 250)
        Catch ex As Exception
            Debug.Write("TCP client suffered an exception when trying to connect:")
            Debug.Write(ex.ToString)
            TCPClient = Nothing
            TCPstream = Nothing
        End Try
        Monitor.Exit(TCPlock)
    End Sub
    Private Sub _Disconnect_from_Device()
        If IsNothing(TCPClient) Or Simulated Then
            Exit Sub
        End If
        DeviceStatusUpdateTimer.Change(Timeout.Infinite, Timeout.Infinite)
        Monitor.Enter(TCPlock)
        Try
            If TCPClient.Connected Then
                TCPstream.Close() 'close the stream
                TCPClient.Close() 'close the client
            End If
        Catch ex As Exception
            Debug.WriteLine("Error disconnecting from TCP host")
        End Try
        TCPClient = Nothing
        TCPstream = Nothing
        Monitor.Exit(TCPlock)
    End Sub

    'read a generic CVE object
    Private Function ReadCVEObject(ObjectIndex As Integer, Optional ByVal SubIndex As Integer = 0) As Object
        If IsNothing(TCPClient) Or Simulated Then
            Return Nothing
        End If

        'Create the message object
        Dim _messsage As New CVE_Message
        _messsage.GenerateSendMessage(CUShort(ObjectIndex), True, CByte(SubIndex))

        ' Send the message to the connected TcpServer. 
        Monitor.Enter(TCPlock)
        Try
            If TCPClient.Connected = False Then
                Connect = True
            End If
            TCPstream.Write(_messsage.SendMessage, 0, _messsage.SendMessage.Length)
        Catch ex As Exception
            Connect = False 'drop the connection
            Debug.WriteLine("Problem writing to the client when reading the CVE object #" & ObjectIndex.ToString & ".")
            Connect = True 'try restarting the connection
        End Try

        ' Read the TcpServer response bytes. 
        Try
            Dim bytes As Int32 = TCPstream.Read(_messsage.ReadMessage, 0, 256)
        Catch ex As Exception
            Connect = False 'drop the connection
            Debug.WriteLine("Problem reading CVE object #" & ObjectIndex.ToString & " from the client.")
            Connect = True 'try restarting the connection
        End Try
        Monitor.Exit(TCPlock)
        If _messsage.ValidResponse Then
            Return _messsage.GetData
        Else
            Return Nothing
        End If

    End Function

    'read all CVE objects
    Private Function ReadAllObjects() As CVE_Data
        If Simulated Then
            Return Nothing
        End If
        Dim bob As New CVE_Data
        '1st CVE object is the "Status Word" as a bit array
        bob.StatusWord = New BitArray(System.BitConverter.GetBytes(CUInt(ReadCVEObject(1))))
        '2nd CVE object is the "Control Word" as bit array
        bob.ControlWord = New BitArray(System.BitConverter.GetBytes(CUInt(ReadCVEObject(2))))
        '3rd CVE object is the Higher Order Control status
        bob.HigherOrderControl = CByte(ReadCVEObject(3))
        '4th CVE object is the Lock Higher Order Control status
        bob.LockHigherOrderControl = CByte(ReadCVEObject(4))
        '6th CVE object is the Target Position of record(s)
        bob.TargetPosition = CInt(ReadCVEObject(6, 3)) 'must have a sub index for this object!
        '7th CVE object is the Velocity of record(s)
        bob.AcutalVelocity = CInt(ReadCVEObject(7, 3)) 'must have a sub index for this object!
        '31st CVE object is the Record Number Preselection
        bob.RecordNumberPreselection = CByte(ReadCVEObject(31))
        '56th CVE object is the Acutal current position of the axis
        bob.ActualPosition = CInt(ReadCVEObject(56))
        '57th CVE object is the Actual Speed reading
        bob.ActualSpeed = CInt(ReadCVEObject(57))
        '58th CVE object is the Actual Current reading
        bob.ActualCurrent = CInt(ReadCVEObject(58))
        '59th CVE object is the Actual Force reading
        bob.ActualForce = CShort(ReadCVEObject(59))
        '60th CVE object is the Setpoint Position reading
        bob.SetpointPosition = CInt(ReadCVEObject(60))
        '61st CVE object is the Setpoint Speed reading
        bob.SetpointSpeed = CInt(ReadCVEObject(61))
        '62nd CVE object is the Nominal Current reading
        bob.NominalCurrent = CInt(ReadCVEObject(62))
        '63rd CVE object is the Setpoint Force value
        bob.SetpointForce = CShort(ReadCVEObject(63))
        '70th CVE object is the Actual Acceleration reading
        bob.ActualAcceleration = CInt(ReadCVEObject(70))
        '72nd CVE object is the Nominal Acceleration value
        bob.NominalAcceleration = CInt(ReadCVEObject(72))
        '96th CVE object is the Position Deviation reading
        bob.PositionDeviation = CInt(ReadCVEObject(96))
        '97th CVE object is the Deviation Velocity reading
        bob.DeviationVelocity = CInt(ReadCVEObject(97))
        '98th CVE object is the Current Deviation reading
        bob.CurrentDeviation = CInt(ReadCVEObject(98))
        '99th CVE object is the Force Deviation reading
        bob.ForceDeviation = CShort(ReadCVEObject(99))
        '120th CVE object is the Nominal Operating Mode
        bob.NominalOperatingMode = CSByte(ReadCVEObject(120))
        '121st CVE object is the Actual Operating Mode
        bob.ActualOperatingMode = CSByte(ReadCVEObject(121))
        '141st CVE object is the Current Record Number
        bob.CurrentRecordNumber = CByte(ReadCVEObject(141))
        '191st CVE object is the Error with Top Priority
        bob.ErrorWithTopPriority = CUShort(ReadCVEObject(191))
        '194th CVE object is the Error with Top Priority Acknowedge Ability
        bob.ErrorWithTopPriorityAcknoledgeAbility = CByte(ReadCVEObject(194))
        '213rd CVE object is the Warning with Top Priority
        bob.WarningWithTopPriority = CUShort(ReadCVEObject(213))
        '217th CVE object is the Power of Ten Conversion Factor
        bob.Power10ConversionFactor = CSByte(ReadCVEObject(217))
        '218th CVE object is the Unit of Measurement Conversion Factor
        bob.UnitOfMeasureConversionFactor = CByte(ReadCVEObject(218))
        '295th CVE object is the Current Target Position
        bob.CurrentTargetPosition = CInt(ReadCVEObject(295))
        '358th CVE object is the Hardware Enable status
        bob.HardwareEnable = CByte(ReadCVEObject(358))
        Return bob
    End Function

    'Get the status word object
    Private Function GetStatusWord() As CVE_SWobject
        If IsNothing(TCPClient) Or Simulated Then
            Return Nothing
        End If
        Dim SW As New CVE_SWobject
        Dim SWbitarray As BitArray = New BitArray(System.BitConverter.GetBytes(CUInt(ReadCVEObject(1))))
        'Dim SW As New CVE_SWobject
        SW.bitArrayTOobject(SWbitarray)
        If SW.W Then
            CollectWarning()
        End If
        If SW.F Then
            CollectError()
        End If
        Return SW
    End Function

    'Collect the error message and raise the event
    Private Sub CollectError()
        If IsNothing(TCPClient) Or Simulated Then
            Exit Sub 'ignore errors
        End If
        'Error message on word 191
        Dim ErrorID As UInt16 = CUShort(ReadCVEObject(191))
        If ErrorID = 47 Then
            'Estop (impossible, power is cut when E-stop is actiated)
            Connect = False
            Exit Sub
        End If
        If ErrorID = 0 Then
            'no error
            Exit Sub
        End If
        'if the error can be acknowledged, its on 194
        Dim ErrorAcknowledge As Byte = CByte(ReadCVEObject(194))
        If ErrorAcknowledge = 255 Then
            'no error
            MsgBox("Unknown Error. Consult the controllers manual, error tables start at page 91. The error code (in decimal) is: " & ErrorID.ToString, MsgBoxStyle.Exclamation, "Error")
        ElseIf ErrorAcknowledge = 2 Then
            'can be eliminated immediately
            If ErrorID = 41 Then
                MsgBox("Cannot move any more in this direction (negative block reached).", MsgBoxStyle.Information, "Limit Reached")
                Dim CW As New CVE_CWobject
                'clear the error
                CW.PSOn = False
                CW.FR = True
                WriteControlWord(CW)
                'wait for hardware to turn on
                Dim SW As CVE_SWobject = GetStatusWord()
                While SW.SOD = False
                    'if its still not ready just keep waiting
                    SW = GetStatusWord()
                End While
                EnableController()
                'MsgBox("Negative block reached")
                'RaiseEvent DriveError("Negative Block")
                'RaiseEvent MoveComplete()
            ElseIf ErrorID = 42 Then
                MsgBox("Cannot move any more in this direction (positive block reached).", MsgBoxStyle.Information, "Limit Reached")
                Dim CW As New CVE_CWobject
                CW.PSOn = False
                CW.FR = True
                WriteControlWord(CW)
                'wait for hardware to turn on
                Dim SW As CVE_SWobject = GetStatusWord()
                While SW.SOD = False
                    'if its still not ready just keep waiting
                    SW = GetStatusWord()
                End While
                EnableController()
                'MsgBox("Positive block reached")
                'RaiseEvent DriveError("Positive Block")
                'RaiseEvent MoveComplete()
            Else
                MsgBox("The error " & ErrorID.ToString & " occured. The error has been cleared and operations can resume.", MsgBoxStyle.Information, "Limit Reached")
                Dim CW As New CVE_CWobject
                CW.PSOn = False
                CW.FR = True
                WriteControlWord(CW)
                'InitialiseDevice()
                'RaiseEvent DriveError("Cleared Error")
            End If

        ElseIf ErrorAcknowledge = 1 Then
            'Malfunction still active
            If ErrorID = 5 Then
                'Zero angle error
                MsgBox("The controller cannot clearly find the reference location. The cause of this error must be removed and the system restarted (powered down). Possible causes include (but not limited to):" & vbCrLf & "Drive is blocked. Ensure it can move freely." & vbCrLf & "Load is too heavy, reduce load weight." & vbCrLf & "The axis is slipping, stiffen and tighten all axis mountings." & vbCrLf & "The load is vibrating under movement. Ensure the load is secure and does not vibrate." & vbCrLf & "If several drives are fitted to the system, only operate one drive at a time." & vbCrLf & "Contoller parameters are set incorrectly. Update the parameters to acurately reflect the axis loading." & vbCrLf & "The motor current limit is set too low, and the motor is unable to move the load. Adjust the current limit, or remove load from the motor.", MsgBoxStyle.Critical, "Critical Error")
                'RaiseEvent DriveError("Zero Angle Error")
            ElseIf ErrorID = 11 Then
                'Zero angle error
                MsgBox("No valid position locations can be found in the parameters file. The controllers firmware needs to be reset and updated.", MsgBoxStyle.Critical, "Critical Error")
                'RaiseEvent DriveError("Parameter File Invalid Error")
            ElseIf ErrorID = 27 Then
                'intermediate circuit voltage too low.
                'probably E-stop
                'do nothing....
            ElseIf ErrorID = 24 Then

            Else
                MsgBox("Unknown Error. Consult the controllers manual, error tables start at page 91. The error code (in decimal) is: " & ErrorID.ToString, MsgBoxStyle.Critical, "Critical Error")
                'RaiseEvent DriveError("Unknown Error")
            End If

        ElseIf ErrorAcknowledge = 0 Then
            'The error cannot be acknoledged. Fatal Error.
            If ErrorID = 1 Then
                'firmware error. contact supplier.
                MsgBox("The controllers firmware has become corrupted. The controller must be serviced by an authorised person. Contact supplier to arrange replacement. This error can not be ignored.", MsgBoxStyle.Critical, "Critical Error")
                'RaiseEvent DriveError("Firmware Error")
            ElseIf ErrorID = 2 Then
                'parameter file invalid. reload the parameter file.
                MsgBox("The controllers parameter file has become corrupted. The controller must be serviced by an authorised person. Contact supplier to arrange serivce. This error can not be ignored.", MsgBoxStyle.Critical, "Critical Error")
                'RaiseEvent DriveError("Parameter File Corrupt Error")
            ElseIf ErrorID = 6 Then
                'encoder error
                MsgBox("The drive cannot find any position encoder signals. Restart the system and re-home the drive axis.", MsgBoxStyle.Critical, "Critical Error")
                'RaiseEvent DriveError("Encoder Error")
            ElseIf ErrorID = 9 Then
                'cannot determine current measurement readings
                MsgBox("The drive cannot read the motors electrical current. The controller must be serviced by an authorised person. Contact supplier to arrange serivce. This error can not be ignored.", MsgBoxStyle.Critical, "Critical Error")
                'RaiseEvent DriveError("Current Error")
            ElseIf ErrorID = 12 Then
                'Firmware update error
                MsgBox("The latest firmware update was unsuccessfull. The controller must be serviced by an authorised person. Contact supplier to arrange serivce. This error can not be ignored.", MsgBoxStyle.Critical, "Critical Error")
                'RaiseEvent DriveError("Firmware Update Error")
            ElseIf ErrorID = 13 Then
                'Overcurrent
                MsgBox("The motor has exceeded its current limit. Check the motor and cabling for short circuits. Replace all defective parts and restart the system.", MsgBoxStyle.Critical, "Critical Error")
                'RaiseEvent DriveError("Overcurrent Error")
            ElseIf ErrorID = 24 Then
                'logic voltage too low. E-stop is probably activated.
                'do nothing...
            ElseIf ErrorID = 27 Then

            Else
                MsgBox("Unknown Error (# " & ErrorID.ToString & "). Consult the controllers manual, error tables start at page 91. The error code (in decimal) is: " & ErrorID.ToString, MsgBoxStyle.Critical, "Critical Error")
                'RaiseEvent DriveError("Unknown Error")
            End If
        End If

    End Sub

    'Collect the warning message and raise the event
    Private Sub CollectWarning()
        If Simulated = True Then
            Exit Sub
        End If
        'warnings are on word 213
        Dim warning As UInt16 = CUShort(ReadCVEObject(213))
        If warning = 52 Then
            Connect = False
            'MsgBox("Emergency Stop Pressed. System has shut down.")
            Exit Sub
        End If
        MsgBox("Warning. Consult the controllers manual, warning tables. The warning code (in decimal) is: " & warning.ToString, MsgBoxStyle.Information, "Controller Warning")
        'RaiseEvent DriveWarning("Unknown Warning")
    End Sub

    'Initialise the Controller/Drive
    Public Sub InitialiseDrive()
        If IsNothing(TCPClient) Or Simulated Then
            Exit Sub
        End If
        EnableController()
        HomeDrive()
    End Sub

    'Get drive into OPERATION ENABLED state
    Private Sub EnableController()
        If IsNothing(TCPClient) Or Simulated Then
            Exit Sub
        End If
        GetHigherOrderControl()
        'Now the device has control, enable it to switch on
        Dim CW As New CVE_CWobject
        CW.FR = False
        CW.QS = True
        CW.EV = True
        CW.SO = False
        WriteControlWord(CW)
        'wait for hardware to turn on
        Dim SW As CVE_SWobject = GetStatusWord()
        While SW.RTSO = False
            'if its still not ready just keep waiting
            SW = GetStatusWord()
        End While

        'if it is ready to switch on, then lets switch it on! :)
        CW.FR = False
        CW.EO = False
        CW.QS = True
        CW.EV = True
        CW.SO = True
        WriteControlWord(CW)
        'wait for the device to turn on
        SW = GetStatusWord()
        If SW.SO = False Then
            'if its still not ready then keep waiting
            SW = GetStatusWord()
        End If

        'activate the operation enabled mode
        CW.FR = False
        CW.EO = True
        CW.QS = True
        CW.EV = True
        CW.SO = True
        WriteControlWord(CW)
        SW = GetStatusWord()
        If SW.OE = False Then
            'if its still not ready keep waiting
            SW = GetStatusWord()
        End If
    End Sub

    'Get the higher order control assigned to the PC
    Private Sub GetHigherOrderControl()
        If IsNothing(TCPClient) Or Simulated Then
            Exit Sub
        End If
        If CInt(ReadCVEObject(4)) <> 0 Then
            'Higher order control is locked! Unlock it first (if possible)
        End If

        'create a message
        Dim _message As New CVE_Message
        _message.GenerateSendMessage(3, False) ' Higher order control CVE object address
        _message.AttachDataToSendMessage(4, 2) ' Data type (UINT08 = 4); Data (ie. 2 = CVE in control)
        Monitor.Enter(TCPlock)
        Try
            If TCPClient.Connected = False Then
                Connect = True
            End If
            ' Send the message to the connected TcpServer. 
            TCPstream.Write(_message.SendMessage, 0, _message.SendMessage.Length)
            ' Read the TcpServer response bytes. 
            TCPstream.Read(_message.ReadMessage, 0, 256)
        Catch ex As Exception
            Connect = False 'drop the connection
            Debug.WriteLine("Problem writing to the client when setting higher order control.")
            Connect = True 'try restarting the connection
        End Try
        Monitor.Exit(TCPlock)
    End Sub

    'write the control word object
    Private Sub WriteControlWord(word As CVE_CWobject)
        If IsNothing(TCPClient) Or Simulated Then
            Exit Sub
        End If
        Dim CW As UInt32 = word.ObjectAsUINT32()
        'structure to store the message
        Dim _message As New CVE_Message
        _message.GenerateSendMessage(2, False)
        _message.AttachDataToSendMessage(2, CW)

        Monitor.Enter(TCPlock)
        Try
            If TCPClient.Connected = False Then
                Connect = True
            End If
            ' Send the message to the connected TcpServer. 
            TCPstream.Write(_message.SendMessage, 0, _message.SendMessage.Length)
            ' Read the TcpServer response bytes. 
            TCPstream.Read(_message.ReadMessage, 0, 256)
        Catch ex As Exception
            Connect = False 'drop the connection
            Debug.WriteLine("Problem writing to the client when writing the control word.")
            Connect = True 'try restarting the connection
            'Exit Sub
        End Try
        Monitor.Exit(TCPlock)
        If _message.ValidResponse Then
            Debug.WriteLine("Successfully sent a control word.")
        Else
            Debug.WriteLine("Error: control word message bits do not match.")
        End If
        'write the control word object

    End Sub

    'Home the drive
    Private Sub HomeDrive()
        If IsNothing(TCPClient) Or Simulated Then
            Exit Sub
        End If

        '--- Set the drive into homing mode -------
        Dim SW As CVE_SWobject = GetStatusWord()
        While SW.OE = False
            'if its still not ready, try to enable the controller
            EnableController()
            SW = GetStatusWord()
        End While
        SetDriveMode(CSByte(6))

        ' --- Enable the homing ----------
        Dim CW As New CVE_CWobject
        CW.FR = False
        CW.QS = True
        CW.EV = True
        CW.SO = True
        CW.EO = True
        CW.ST = True
        WriteControlWord(CW)
        'wait till the drive has finished moving

        SW = GetStatusWord()
        While SW.TR = False
            SW = GetStatusWord()
        End While
        ' -- Reset the start signal ----
        CW.FR = False
        CW.QS = True
        CW.EV = True
        CW.SO = True
        CW.EO = True
        CW.ST = False
        WriteControlWord(CW)
    End Sub

    'Set the drive mode state
    Private Sub SetDriveMode(ByVal mode As SByte)
        If IsNothing(TCPClient) Or Simulated Then
            Exit Sub
        End If

        'structure to store the message
        Dim _message As New CVE_Message
        _message.GenerateSendMessage(120, False)
        _message.AttachDataToSendMessage(8, mode)
        Monitor.Enter(TCPlock)
        Try
            If TCPClient.Connected = False Then
                Connect = True
            End If
            ' Send the message to the connected TcpServer. 
            TCPstream.Write(_message.SendMessage, 0, _message.SendMessage.Length)
            ' Read the TcpServer response bytes. 
            TCPstream.Read(_message.ReadMessage, 0, 256)
        Catch ex As Exception
            Connect = False 'drop the connection
            Debug.WriteLine("Problem writing to the client when setting the drive mode.")
            Connect = True 'try restarting the connection
        End Try
        Monitor.Exit(TCPlock)
    End Sub

    'Move to position record
    Public Sub MoveToPosition(ByVal record As Byte)
        'Take care of a glitched up TCP situation, a simulation, or an invalid record.
        If IsNothing(TCPClient) Or Simulated Or record = 0 Then
            If record <> 0 Then
                Threading.Thread.Sleep(1000)
            End If
            Exit Sub
        End If
        'Check that the drive has been referenced - If not -> home the drive -
        Dim SW As CVE_SWobject = GetStatusWord()
        While SW.AR = False
            'if its still not referenced, then go to homing function
            HomeDrive()
        End While
        'Check that the drive is in positioning mode - If not -> change to position mode -
        If CByte(ReadCVEObject(120)) <> 1 Then
            SetDriveMode(CSByte(1))
        End If

        'If the drive is already moving (maybe two parrallel calls??) wait till the drive has finished moving
        SW = GetStatusWord()
        While SW.TR = False
            SW = GetStatusWord()
        End While

        'Move to the position
        'SelectPositionRecord(record)
        Dim _message As New CVE_Message
        _message.GenerateSendMessage(31, False)
        _message.AttachDataToSendMessage(4, record)
        Monitor.Enter(TCPlock)
        Try
            If TCPClient.Connected = False Then
                Connect = True
            End If
            ' Send the message to the connected TcpServer. 
            TCPstream.Write(_message.SendMessage, 0, _message.SendMessage.Length)
            ' Read the TcpServer response bytes. 
            TCPstream.Read(_message.ReadMessage, 0, 256)
        Catch ex As Exception
            Connect = False 'drop the connection
            Debug.WriteLine("Problem writing to the client when moving to positoin record #" & record.ToString & ".")
            Connect = True 'try restarting the connection
        End Try
        Monitor.Exit(TCPlock)
        ' --- Enable the move ----------
        Dim CW As New CVE_CWobject
        CW.FR = False
        CW.QS = True
        CW.EV = True
        CW.SO = True
        CW.EO = True
        CW.ST = True
        WriteControlWord(CW)
        'wait till the drive has finished moving

        SW = GetStatusWord()
        While SW.TR = False
            SW = GetStatusWord()
        End While

        ' -- Reset the start signal ----
        CW.FR = False
        CW.QS = True
        CW.EV = True
        CW.SO = True
        CW.EO = True
        CW.ST = False
        WriteControlWord(CW)
    End Sub

    'Set position record relative move (mm)
    Private Sub SetPositionRecordRelativeValue(ByVal MoveByMM As Double)
        'Calculate the SINC value for this move
        Dim MoveBySINC As Integer = 0
        MoveBySINC = CInt(MoveByMM * 1000)
        'SelectPositionRecord(record)
        Dim _message As New CVE_Message
        _message.GenerateSendMessage(6, False, 25)
        _message.AttachDataToSendMessage(6, MoveBySINC)
        Monitor.Enter(TCPlock)
        Try
            If TCPClient.Connected = False Then
                Connect = True
            End If
            ' Send the message to the connected TcpServer. 
            TCPstream.Write(_message.SendMessage, 0, _message.SendMessage.Length)
            ' Read the TcpServer response bytes. 
            TCPstream.Read(_message.ReadMessage, 0, 256)
        Catch ex As Exception
            Connect = False 'drop the connection
            Debug.WriteLine("Problem writing to the client when setting the relative position " & MoveBySINC.ToString & "(SINC) to the record #25.")
            Connect = True 'try restarting the connection
        End Try
        Monitor.Exit(TCPlock)
    End Sub

    'set position record velocity
    Public Sub SetPositionRecordVelocity(ByVal VelocityMMs As Double)
        'Calculate the SINC value for this velocity
        Dim VelocitySINC As Integer = 0
        VelocitySINC = CInt(VelocityMMs * 1000)
        'SelectPositionRecord(record)
        Dim _message As New CVE_Message
        _message.GenerateSendMessage(7, False, 25)
        _message.AttachDataToSendMessage(6, VelocitySINC)
        Monitor.Enter(TCPlock)
        Try
            If TCPClient.Connected = False Then
                Connect = True
            End If
            ' Send the message to the connected TcpServer. 
            TCPstream.Write(_message.SendMessage, 0, _message.SendMessage.Length)
            ' Read the TcpServer response bytes. 
            TCPstream.Read(_message.ReadMessage, 0, 256)
        Catch ex As Exception
            Connect = False 'drop the connection
            Debug.WriteLine("Problem writing to the client when setting the velocity " & VelocitySINC.ToString & "(SINC) to the record #25.")
            Connect = True 'try restarting the connection
        End Try
        Monitor.Exit(TCPlock)
    End Sub

    'Update the device status variable
    Private Sub DeviceStatusUpdateTimer_Tick(ByVal state As Object)
        DeviceStatus = ReadAllObjects()
    End Sub
End Class

'Public message
Public Class CVE_Message
        'structure to store the message
        Private _message(30) As Byte
        Private _messageLength As Byte
        Private _responseMessage(256) As Byte
        Private rnd As New Random 'use the to generate random numbers for MessageID handling
        Private _SendID As UInt32 = CUInt(rnd.Next(1, 42949671))

        Public ReadOnly Property SendMessage As Byte()
            Get
                Dim _Tmessage(_messageLength) As Byte
                For i As Integer = 0 To _messageLength
                    _Tmessage(i) = _message(i)
                Next
                Return _Tmessage
            End Get
        End Property

        Public Property ReadMessage As Byte()
            Get
                Return _responseMessage
            End Get
            Set(value As Byte())
                If Not IsNothing(value) Then
                    _responseMessage = value
                End If
            End Set
        End Property

        Public Sub GenerateSendMessage(ByVal CVE_object_ID As UInt16, ByVal Read_Object As Boolean, Optional ByVal SubIndex As Byte = 0)
            If Read_Object Then
                _message(0) = 16 ' 0x10 = Read CVE object from controller
            Else
                _message(0) = 17 ' 0x11 = Write CVE object to controller
            End If


            'Generate random message ID
            Dim MessageID_bytes() As Byte = BitConverter.GetBytes(_SendID)
            _message(1) = MessageID_bytes(0)  ' Message ID byte 1 (optional)
            _message(2) = MessageID_bytes(1)  ' Message ID byte 2 (optional)
            _message(3) = MessageID_bytes(2)  ' Message ID byte 3 (optional)
            _message(4) = MessageID_bytes(3)  ' Message ID byte 4 (optional)

            Dim DataLength_bytes() As Byte = BitConverter.GetBytes(4)
            _message(5) = DataLength_bytes(0)  ' Data Length: Always 4 for this request
            _message(6) = DataLength_bytes(1)  ' Data Length: Always 4 for this request
            _message(7) = DataLength_bytes(2)  ' Data Length: Always 4 for this request
            _message(8) = DataLength_bytes(3)  ' Data Length: Always 4 for this request

            _message(9) = 0  ' Acknowledge: Always zero

            Dim Reserved1_bytes() As Byte = BitConverter.GetBytes(0)
            _message(10) = Reserved1_bytes(0) ' Reserved for future use: Always zero
            _message(11) = Reserved1_bytes(1) ' Reserved for future use: Always zero
            _message(12) = Reserved1_bytes(2) ' Reserved for future use: Always zero
            _message(13) = Reserved1_bytes(3) ' Reserved for future use: Always zero

            Dim ObjectIndex_bytes() As Byte = BitConverter.GetBytes(CVE_object_ID)
            _message(14) = ObjectIndex_bytes(0)     ' Index of CVE object address (upper byte)
            _message(15) = ObjectIndex_bytes(1)    ' Index of CVE object address (lower byte)

            _message(16) = SubIndex ' Object subindex

            _message(17) = 0 ' Reserved: Always zero
            _messageLength = 17
        End Sub

        Public Sub AttachDataToSendMessage(ByVal dataType As Byte, ByVal data As Object)

            If dataType = 2 Then 'UINT32
                Dim DataLength_bytes() As Byte = BitConverter.GetBytes(8)
                _message(5) = DataLength_bytes(0)  ' Data Length: Always 4 for this request
                _message(6) = DataLength_bytes(1)  ' Data Length: Always 4 for this request
                _message(7) = DataLength_bytes(2)  ' Data Length: Always 4 for this request
                _message(8) = DataLength_bytes(3)  ' Data Length: Always 4 for this request

                _message(17) = 2 ' Data type (UINT32 = 2)

                Dim Data_bytes() As Byte = BitConverter.GetBytes(CUInt(data))
                _message(18) = Data_bytes(0) ' Data 
                _message(19) = Data_bytes(1) ' Data 
                _message(20) = Data_bytes(2) ' Data 
                _message(21) = Data_bytes(3) ' Data 

                _messageLength = 21
            End If
            If dataType = 3 Then 'UINT16
                Dim DataLength_bytes() As Byte = BitConverter.GetBytes(6)
                _message(5) = DataLength_bytes(0)  ' Data Length: Always 4 for this request
                _message(6) = DataLength_bytes(1)  ' Data Length: Always 4 for this request
                _message(7) = DataLength_bytes(2)  ' Data Length: Always 4 for this request
                _message(8) = DataLength_bytes(3)  ' Data Length: Always 4 for this request

                _message(17) = 3 ' Data type (UINT32 = 2)

                Dim Data_bytes() As Byte = BitConverter.GetBytes(CUShort(data))
                _message(18) = Data_bytes(0) ' Data 
                _message(19) = Data_bytes(1) ' Data 

                _messageLength = 19
            End If
            If dataType = 4 Then ' UINT8
                Dim DataLength_bytes() As Byte = BitConverter.GetBytes(5)
                _message(5) = DataLength_bytes(0)  ' Data Length: Always 4 for this request
                _message(6) = DataLength_bytes(1)  ' Data Length: Always 4 for this request
                _message(7) = DataLength_bytes(2)  ' Data Length: Always 4 for this request
                _message(8) = DataLength_bytes(3)  ' Data Length: Always 4 for this request
                'Data is byte
                _message(17) = CByte(4)
                _message(18) = CByte(data)
                _messageLength = 18
            End If
            If dataType = 6 Then 'SINT32
                Dim DataLength_bytes() As Byte = BitConverter.GetBytes(8)
                _message(5) = DataLength_bytes(0)  ' Data Length: Always 4 for this request
                _message(6) = DataLength_bytes(1)  ' Data Length: Always 4 for this request
                _message(7) = DataLength_bytes(2)  ' Data Length: Always 4 for this request
                _message(8) = DataLength_bytes(3)  ' Data Length: Always 4 for this request
                _message(17) = CByte(6) 'data  is SINT32

                Dim Data_bytes() As Byte = BitConverter.GetBytes(CInt(data))
                _message(18) = Data_bytes(0) ' Data 
                _message(19) = Data_bytes(1) ' Data 
                _message(20) = Data_bytes(2) ' Data 
                _message(21) = Data_bytes(3) ' Data 
                _messageLength = 21
            End If
            If dataType = 7 Then 'SINT16
                Dim DataLength_bytes() As Byte = BitConverter.GetBytes(6)
                _message(5) = DataLength_bytes(0)  ' Data Length: Always 4 for this request
                _message(6) = DataLength_bytes(1)  ' Data Length: Always 4 for this request
                _message(7) = DataLength_bytes(2)  ' Data Length: Always 4 for this request
                _message(8) = DataLength_bytes(3)  ' Data Length: Always 4 for this request
                _message(17) = CByte(6) 'data  is SINT32

                Dim Data_bytes() As Byte = BitConverter.GetBytes(CShort(data))
                _message(18) = Data_bytes(0) ' Data 
                _message(19) = Data_bytes(1) ' Data 
                _messageLength = 19
            End If
            If dataType = 8 Then 'SINT8
                Dim DataLength_bytes() As Byte = BitConverter.GetBytes(5)
                _message(5) = DataLength_bytes(0)  ' Data Length: Always 4 for this request
                _message(6) = DataLength_bytes(1)  ' Data Length: Always 4 for this request
                _message(7) = DataLength_bytes(2)  ' Data Length: Always 4 for this request
                _message(8) = DataLength_bytes(3)  ' Data Length: Always 4 for this request
                _message(17) = 8 ' Data type (SINT08 = 8)

                If CSByte(data) > 0 Then
                    _message(18) = CByte(data) ' Data 
                Else
                    Dim Tmode As Integer = CInt(data)
                    Tmode = Tmode + 255
                    Dim Data_bytes() As Byte = BitConverter.GetBytes(Tmode)
                    _message(18) = Data_bytes(0)
                End If
                _messageLength = 18
            End If

        End Sub

        Public ReadOnly Property ValidResponse As Boolean
            Get
                'check the Message ID of the response matches that of the acquired data
                Dim ReceiveMessageID As UInteger = BitConverter.ToUInt32(_responseMessage, 1)
                If ReceiveMessageID <> _SendID Then
                    Debug.WriteLine("Receiving bad information from the client when reading the CVE object.")
                    Debug.WriteLine("The Send ID (" & _SendID.ToString & ") does not equal Receive ID (" & ReceiveMessageID.ToString & ").")
                    Return False
                Else
                    Return True
                End If
            End Get
        End Property

        Public ReadOnly Property GetData As Object
            Get
                Dim returnVal As Object = Nothing
                'Check the data type received (to determine how many bytes to read)
                Dim ReceivedDataType As Byte = _responseMessage(17)
                If ReceivedDataType = 2 Then
                    'UINT32
                    returnVal = New UInt32
                    returnVal = BitConverter.ToUInt32(_responseMessage, 18)
                ElseIf ReceivedDataType = 3 Then
                    'UINT16
                    returnVal = New UInt16
                    returnVal = BitConverter.ToUInt16(_responseMessage, 18)
                ElseIf ReceivedDataType = 4 Then
                    'UINT08
                    returnVal = New Byte
                    returnVal = _responseMessage(18)
                ElseIf ReceivedDataType = 6 Then
                    'SINT32
                    returnVal = New Int32
                    returnVal = BitConverter.ToInt32(_responseMessage, 18)
                ElseIf ReceivedDataType = 7 Then
                    'SINT16
                    returnVal = New Int16
                    returnVal = BitConverter.ToInt16(_responseMessage, 18)
                ElseIf ReceivedDataType = 8 Then
                    'SINT08
                    returnVal = New SByte
                    If _responseMessage(18) < 128 Then
                        Return _responseMessage(18)
                    Else
                        Dim Tmessage As Int32 = CInt(_responseMessage(18))
                        Tmessage = Tmessage - 256
                        Return CSByte(Tmessage)
                    End If
                End If

                Return returnVal
            End Get
        End Property


    End Class

    'Public objects structure
    Public Class CVE_Data
        Public StatusWord As BitArray
        Public ControlWord As BitArray
        Public HigherOrderControl As Byte
        Public LockHigherOrderControl As Byte
        Public TargetPosition As Int32
        Public AcutalVelocity As Int32
        Public RecordNumberPreselection As Byte
        Public ActualPosition As Int32
        Public ActualSpeed As Int32
        Public ActualCurrent As Int32
        Public ActualForce As Int16
        Public SetpointPosition As Int32
        Public SetpointSpeed As Int32
        Public NominalCurrent As Int32
        Public SetpointForce As Int16
        Public ActualAcceleration As Int32
        Public NominalAcceleration As Int32
        Public PositionDeviation As Int32
        Public DeviationVelocity As Int32
        Public CurrentDeviation As Int32
        Public ForceDeviation As Int16
        Public SaveAllObjects As UInt32
        Public NominalOperatingMode As SByte
        Public ActualOperatingMode As SByte
        Public CurrentRecordNumber As Byte
        Public ErrorWithTopPriority As UInt16
        Public ErrorWithTopPriorityAcknoledgeAbility As Byte
        Public WarningWithTopPriority As UInt16
        Public Power10ConversionFactor As SByte
        Public UnitOfMeasureConversionFactor As Byte
        Public CurrentTargetPosition As Int32
        Public HardwareEnable As Byte

    End Class

'Public ControlWord structure
Public Class CVE_CWobject
    Public SO As Boolean
    Public EV As Boolean
    Public QS As Boolean
    Public EO As Boolean
    Public ST As Boolean
    Public PSOn As Boolean
    Public FR As Boolean
    Public STP As Boolean

    Public Function ObjectAsUINT32() As UInt32
        Dim CWobject(31) As Boolean
        CWobject(0) = SO
        CWobject(1) = EV
        CWobject(2) = QS
        CWobject(3) = EO
        CWobject(4) = ST
        CWobject(6) = PSOn
        CWobject(7) = FR
        CWobject(8) = STP
        Return FromBits(CWobject)
    End Function

    Private Shared Function FromBits(myBits As Boolean()) As UInteger
        Dim result As UInteger = 0
        Dim bit As UInteger = &H80000000UI
        For i As Integer = 31 To 0 Step -1
            If myBits(i) Then
                result = result Or bit
            End If
            bit >>= 1
        Next
        Return result
    End Function

End Class

'Public ControlWord structure
Public Class CVE_SWobject
    Public RTSO As Boolean = False
    Public SO As Boolean = False
    Public OE As Boolean = False
    Public F As Boolean = False
    Public QS As Boolean = False
    Public SOD As Boolean = False
    Public W As Boolean = False
    Public MOV As Boolean = False
    Public TR As Boolean = False
    Public SACK As Boolean = False
    Public AR As Boolean = False
    Public DPB As Boolean = False
    Public DNB As Boolean = False

    Public Sub bitArrayTOobject(ByVal SWasBitArray As BitArray)
        If SWasBitArray(0) Then
            RTSO = True
        End If
        If SWasBitArray(1) Then
            SO = True
        End If
        If SWasBitArray(2) Then
            OE = True
        End If
        If SWasBitArray(3) Then
            F = True
        End If
        If SWasBitArray(5) Then
            QS = True
        End If
        If SWasBitArray(6) Then
            SOD = True
        End If
        If SWasBitArray(7) Then
            W = True
        End If
        If SWasBitArray(8) Then
            MOV = True
        End If
        If SWasBitArray(10) Then
            TR = True
        End If
        If SWasBitArray(12) Then
            SACK = True
        End If
        If SWasBitArray(15) Then
            AR = True
        End If
        If SWasBitArray(30) Then
            DPB = True
        End If
        If SWasBitArray(31) Then
            DNB = True
        End If
    End Sub

End Class